// Code generated by extensionsgen. DO NOT EDIT.
package options

import (
	"fmt"
	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/checker"
	"github.com/google/cel-go/common/decls"
	"github.com/google/cel-go/common/types"
	"github.com/google/cel-go/common/types/ref"
	"google.golang.org/genproto/googleapis/api/expr/v1alpha1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
)

// OptionBuilder is the interface that all option builders must implement
type OptionBuilder interface {
	// Build creates the actual CEL environment option
	Build() (cel.EnvOption, error)
	// Name returns the name of the option
	Name() string
	// Description returns a description of what this option does
	Description() string
}

// FromJSON is the interface that maintainers implement for options they want to expose to WASM
type FromJSON interface {
	// FromJSON configures the option builder from JSON parameters
	FromJSON(params map[string]interface{}) error
}

// Registry holds all available option builders
type Registry struct {
	builders map[string]func() OptionBuilder
}

// NewRegistry creates a new option registry
func NewRegistry() *Registry {
	return &Registry{builders: make(map[string]func() OptionBuilder)}
}

// Register registers an option builder factory function
func (r *Registry) Register(name string, factory func() OptionBuilder) {
	r.builders[name] = factory
}

// Create creates a new option builder by name
func (r *Registry) Create(name string) (OptionBuilder, error) {
	factory, exists := r.builders[name]
	if !exists {
		return nil, fmt.Errorf("option %q not found", name)
	}
	return factory(), nil
}

// List returns all available option names
func (r *Registry) List() []string {
	var names []string
	for name := range r.builders {
		names = append(names, name)
	}
	return names
}

// ListWithFromJSON returns option names that implement the FromJSON interface
func (r *Registry) ListWithFromJSON() []string {
	var names []string
	for name, factory := range r.builders {
		builder := factory()
		if _, ok := builder.(FromJSON); ok {
			names = append(names, name)
		}
	}
	return names
}

// DefaultRegistry is the default registry with all built-in options
var DefaultRegistry = NewRegistry()

// ASTValidators configures a set of ASTValidator instances into the target environment.
// Validators are applied in the order in which the are specified and are treated as singletons.
// The same ASTValidator with a given name will not be applied more than once.
type ASTValidatorsBuilder struct {
	Validators []cel.ASTValidator
}

// Name returns the name of this option
func (b *ASTValidatorsBuilder) Name() string {
	return "ASTValidators"
}

// Description returns the description of this option
func (b *ASTValidatorsBuilder) Description() string {
	return "ASTValidators configures a set of ASTValidator instances into the target environment.\n\nValidators are applied in the order in which the are specified and are treated as singletons.\nThe same ASTValidator with a given name will not be applied more than once."
}

// SetValidators sets the validators parameter
func (b *ASTValidatorsBuilder) SetValidators(validators []cel.ASTValidator) *ASTValidatorsBuilder {
	b.Validators = validators
	return b
}

// Build creates the CEL environment option
func (b *ASTValidatorsBuilder) Build() (cel.EnvOption, error) {
	return cel.ASTValidators(b.Validators...), nil
}
func init() {
	DefaultRegistry.Register("ASTValidators", func() OptionBuilder {
		return &ASTValidatorsBuilder{}
	})
}

// Abbrevs configures a set of simple names as abbreviations for fully-qualified names.
// An abbreviation (abbrev for short) is a simple name that expands to a fully-qualified name.
// Abbreviations can be useful when working with variables, functions, and especially types from
// multiple namespaces:
// CEL object construction
// qual.pkg.version.ObjTypeName{
// field: alt.container.ver.FieldTypeName{value: ...}
// }
// Only one the qualified names above may be used as the CEL container, so at least one of these
// references must be a long qualified name within an otherwise short CEL program. Using the
// following abbreviations, the program becomes much simpler:
// CEL Go option
// Abbrevs("qual.pkg.version.ObjTypeName", "alt.container.ver.FieldTypeName")
// Simplified Object construction
// ObjTypeName{field: FieldTypeName{value: ...}}
// There are a few rules for the qualified names and the simple abbreviations generated from them:
// - Qualified names must be dot-delimited, e.g. `package.subpkg.name`.
// - The last element in the qualified name is the abbreviation.
// - Abbreviations must not collide with each other.
// - The abbreviation must not collide with unqualified names in use.
// Abbreviations are distinct from container-based references in the following important ways:
// - Abbreviations must expand to a fully-qualified name.
// - Expanded abbreviations do not participate in namespace resolution.
// - Abbreviation expansion is done instead of the container search for a matching identifier.
// - Containers follow C++ namespace resolution rules with searches from the most qualified name
// to the least qualified name.
// - Container references within the CEL program may be relative, and are resolved to fully
// qualified names at either type-check time or program plan time, whichever comes first.
// If there is ever a case where an identifier could be in both the container and as an
// abbreviation, the abbreviation wins as this will ensure that the meaning of a program is
// preserved between compilations even as the container evolves.
type AbbrevsBuilder struct {
	QualifiedNames []string
}

// Name returns the name of this option
func (b *AbbrevsBuilder) Name() string {
	return "Abbrevs"
}

// Description returns the description of this option
func (b *AbbrevsBuilder) Description() string {
	return "Abbrevs configures a set of simple names as abbreviations for fully-qualified names.\n\nAn abbreviation (abbrev for short) is a simple name that expands to a fully-qualified name.\nAbbreviations can be useful when working with variables, functions, and especially types from\nmultiple namespaces:\n\n\t// CEL object construction\n\tqual.pkg.version.ObjTypeName{\n\t   field: alt.container.ver.FieldTypeName{value: ...}\n\t}\n\nOnly one the qualified names above may be used as the CEL container, so at least one of these\nreferences must be a long qualified name within an otherwise short CEL program. Using the\nfollowing abbreviations, the program becomes much simpler:\n\n\t// CEL Go option\n\tAbbrevs(\"qual.pkg.version.ObjTypeName\", \"alt.container.ver.FieldTypeName\")\n\t// Simplified Object construction\n\tObjTypeName{field: FieldTypeName{value: ...}}\n\nThere are a few rules for the qualified names and the simple abbreviations generated from them:\n- Qualified names must be dot-delimited, e.g. `package.subpkg.name`.\n- The last element in the qualified name is the abbreviation.\n- Abbreviations must not collide with each other.\n- The abbreviation must not collide with unqualified names in use.\n\nAbbreviations are distinct from container-based references in the following important ways:\n- Abbreviations must expand to a fully-qualified name.\n- Expanded abbreviations do not participate in namespace resolution.\n- Abbreviation expansion is done instead of the container search for a matching identifier.\n- Containers follow C++ namespace resolution rules with searches from the most qualified name\n\n\tto the least qualified name.\n\n- Container references within the CEL program may be relative, and are resolved to fully\n\n\tqualified names at either type-check time or program plan time, whichever comes first.\n\nIf there is ever a case where an identifier could be in both the container and as an\nabbreviation, the abbreviation wins as this will ensure that the meaning of a program is\npreserved between compilations even as the container evolves."
}

// SetQualifiedNames sets the qualifiedNames parameter
func (b *AbbrevsBuilder) SetQualifiedNames(qualifiedNames []string) *AbbrevsBuilder {
	b.QualifiedNames = qualifiedNames
	return b
}

// Build creates the CEL environment option
func (b *AbbrevsBuilder) Build() (cel.EnvOption, error) {
	return cel.Abbrevs(b.QualifiedNames...), nil
}
func init() {
	DefaultRegistry.Register("Abbrevs", func() OptionBuilder {
		return &AbbrevsBuilder{}
	})
}

// ClearMacros options clears all parser macros.
// Clearing macros will ensure CEL expressions can only contain linear evaluation paths, as
// comprehensions such as `all` and `exists` are enabled only via macros.
type ClearMacrosBuilder struct{}

// Name returns the name of this option
func (b *ClearMacrosBuilder) Name() string {
	return "ClearMacros"
}

// Description returns the description of this option
func (b *ClearMacrosBuilder) Description() string {
	return "ClearMacros options clears all parser macros.\n\nClearing macros will ensure CEL expressions can only contain linear evaluation paths, as\ncomprehensions such as `all` and `exists` are enabled only via macros."
}

// Build creates the CEL environment option
func (b *ClearMacrosBuilder) Build() (cel.EnvOption, error) {
	return cel.ClearMacros(), nil
}
func init() {
	DefaultRegistry.Register("ClearMacros", func() OptionBuilder {
		return &ClearMacrosBuilder{}
	})
}

// Constant creates an instances of an identifier declaration with a variable name, type, and value.
type ConstantBuilder struct {
	NameValue string
	T         *cel.Type
	V         ref.Val
}

// Name returns the name of this option
func (b *ConstantBuilder) Name() string {
	return "Constant"
}

// Description returns the description of this option
func (b *ConstantBuilder) Description() string {
	return "Constant creates an instances of an identifier declaration with a variable name, type, and value."
}

// SetName sets the name parameter
func (b *ConstantBuilder) SetName(name string) *ConstantBuilder {
	b.NameValue = name
	return b
}

// SetT sets the t parameter
func (b *ConstantBuilder) SetT(t *cel.Type) *ConstantBuilder {
	b.T = t
	return b
}

// SetV sets the v parameter
func (b *ConstantBuilder) SetV(v ref.Val) *ConstantBuilder {
	b.V = v
	return b
}

// Build creates the CEL environment option
func (b *ConstantBuilder) Build() (cel.EnvOption, error) {
	return cel.Constant(b.NameValue, b.T, b.V), nil
}
func init() {
	DefaultRegistry.Register("Constant", func() OptionBuilder {
		return &ConstantBuilder{}
	})
}

// Container sets the container for resolving variable names. Defaults to an empty container.
// If all references within an expression are relative to a protocol buffer package, then
// specifying a container of `google.type` would make it possible to write expressions such as
// `Expr{expression: 'a < b'}` instead of having to write `google.type.Expr{...}`.
type ContainerBuilder struct {
	NameValue string
}

// Name returns the name of this option
func (b *ContainerBuilder) Name() string {
	return "Container"
}

// Description returns the description of this option
func (b *ContainerBuilder) Description() string {
	return "Container sets the container for resolving variable names. Defaults to an empty container.\n\nIf all references within an expression are relative to a protocol buffer package, then\nspecifying a container of `google.type` would make it possible to write expressions such as\n`Expr{expression: 'a < b'}` instead of having to write `google.type.Expr{...}`."
}

// SetName sets the name parameter
func (b *ContainerBuilder) SetName(name string) *ContainerBuilder {
	b.NameValue = name
	return b
}

// Build creates the CEL environment option
func (b *ContainerBuilder) Build() (cel.EnvOption, error) {
	return cel.Container(b.NameValue), nil
}
func init() {
	DefaultRegistry.Register("Container", func() OptionBuilder {
		return &ContainerBuilder{}
	})
}

// CostEstimatorOptions configure type-check time options for estimating expression cost.
type CostEstimatorOptionsBuilder struct {
	CostOpts []checker.CostOption
}

// Name returns the name of this option
func (b *CostEstimatorOptionsBuilder) Name() string {
	return "CostEstimatorOptions"
}

// Description returns the description of this option
func (b *CostEstimatorOptionsBuilder) Description() string {
	return "CostEstimatorOptions configure type-check time options for estimating expression cost."
}

// SetCostOpts sets the costOpts parameter
func (b *CostEstimatorOptionsBuilder) SetCostOpts(costOpts []checker.CostOption) *CostEstimatorOptionsBuilder {
	b.CostOpts = costOpts
	return b
}

// Build creates the CEL environment option
func (b *CostEstimatorOptionsBuilder) Build() (cel.EnvOption, error) {
	return cel.CostEstimatorOptions(b.CostOpts...), nil
}
func init() {
	DefaultRegistry.Register("CostEstimatorOptions", func() OptionBuilder {
		return &CostEstimatorOptionsBuilder{}
	})
}

// CrossTypeNumericComparisons makes it possible to compare across numeric types, e.g. double < int
type CrossTypeNumericComparisonsBuilder struct {
	Enabled bool
}

// Name returns the name of this option
func (b *CrossTypeNumericComparisonsBuilder) Name() string {
	return "CrossTypeNumericComparisons"
}

// Description returns the description of this option
func (b *CrossTypeNumericComparisonsBuilder) Description() string {
	return "CrossTypeNumericComparisons makes it possible to compare across numeric types, e.g. double < int"
}

// SetEnabled sets the enabled parameter
func (b *CrossTypeNumericComparisonsBuilder) SetEnabled(enabled bool) *CrossTypeNumericComparisonsBuilder {
	b.Enabled = enabled
	return b
}

// Build creates the CEL environment option
func (b *CrossTypeNumericComparisonsBuilder) Build() (cel.EnvOption, error) {
	return cel.CrossTypeNumericComparisons(b.Enabled), nil
}
func init() {
	DefaultRegistry.Register("CrossTypeNumericComparisons", func() OptionBuilder {
		return &CrossTypeNumericComparisonsBuilder{}
	})
}

// CustomTypeAdapter swaps the default types.Adapter implementation with a custom one.
// Note: This option must be specified before the Types and TypeDescs options when used together.
type CustomTypeAdapterBuilder struct {
	Adapter types.Adapter
}

// Name returns the name of this option
func (b *CustomTypeAdapterBuilder) Name() string {
	return "CustomTypeAdapter"
}

// Description returns the description of this option
func (b *CustomTypeAdapterBuilder) Description() string {
	return "CustomTypeAdapter swaps the default types.Adapter implementation with a custom one.\n\nNote: This option must be specified before the Types and TypeDescs options when used together."
}

// SetAdapter sets the adapter parameter
func (b *CustomTypeAdapterBuilder) SetAdapter(adapter types.Adapter) *CustomTypeAdapterBuilder {
	b.Adapter = adapter
	return b
}

// Build creates the CEL environment option
func (b *CustomTypeAdapterBuilder) Build() (cel.EnvOption, error) {
	return cel.CustomTypeAdapter(b.Adapter), nil
}
func init() {
	DefaultRegistry.Register("CustomTypeAdapter", func() OptionBuilder {
		return &CustomTypeAdapterBuilder{}
	})
}

// Declarations option extends the declaration set configured in the environment.
// Note: Declarations will by default be appended to the pre-existing declaration set configured
// for the environment. The NewEnv call builds on top of the standard CEL declarations. For a
// purely custom set of declarations use NewCustomEnv.
// Deprecated: use FunctionDecls and VariableDecls or FromConfig instead.
type DeclarationsBuilder struct {
	Decls []*expr.Decl
}

// Name returns the name of this option
func (b *DeclarationsBuilder) Name() string {
	return "Declarations"
}

// Description returns the description of this option
func (b *DeclarationsBuilder) Description() string {
	return "Declarations option extends the declaration set configured in the environment.\n\nNote: Declarations will by default be appended to the pre-existing declaration set configured\nfor the environment. The NewEnv call builds on top of the standard CEL declarations. For a\npurely custom set of declarations use NewCustomEnv.\n\nDeprecated: use FunctionDecls and VariableDecls or FromConfig instead."
}

// SetDecls sets the decls parameter
func (b *DeclarationsBuilder) SetDecls(decls []*expr.Decl) *DeclarationsBuilder {
	b.Decls = decls
	return b
}

// Build creates the CEL environment option
func (b *DeclarationsBuilder) Build() (cel.EnvOption, error) {
	return cel.Declarations(b.Decls...), nil
}
func init() {
	DefaultRegistry.Register("Declarations", func() OptionBuilder {
		return &DeclarationsBuilder{}
	})
}

// DeclareContextProto returns an option to extend CEL environment with declarations from the given context proto.
// Each field of the proto defines a variable of the same name in the environment.
// https://github.com/google/cel-spec/blob/master/doc/langdef.md#evaluation-environment
type DeclareContextProtoBuilder struct {
	Descriptor protoreflect.MessageDescriptor
}

// Name returns the name of this option
func (b *DeclareContextProtoBuilder) Name() string {
	return "DeclareContextProto"
}

// Description returns the description of this option
func (b *DeclareContextProtoBuilder) Description() string {
	return "DeclareContextProto returns an option to extend CEL environment with declarations from the given context proto.\nEach field of the proto defines a variable of the same name in the environment.\nhttps://github.com/google/cel-spec/blob/master/doc/langdef.md#evaluation-environment"
}

// SetDescriptor sets the descriptor parameter
func (b *DeclareContextProtoBuilder) SetDescriptor(descriptor protoreflect.MessageDescriptor) *DeclareContextProtoBuilder {
	b.Descriptor = descriptor
	return b
}

// Build creates the CEL environment option
func (b *DeclareContextProtoBuilder) Build() (cel.EnvOption, error) {
	return cel.DeclareContextProto(b.Descriptor), nil
}
func init() {
	DefaultRegistry.Register("DeclareContextProto", func() OptionBuilder {
		return &DeclareContextProtoBuilder{}
	})
}

// DefaultUTCTimeZone ensures that time-based operations use the UTC timezone rather than the
// input time's local timezone.
type DefaultUTCTimeZoneBuilder struct {
	Enabled bool
}

// Name returns the name of this option
func (b *DefaultUTCTimeZoneBuilder) Name() string {
	return "DefaultUTCTimeZone"
}

// Description returns the description of this option
func (b *DefaultUTCTimeZoneBuilder) Description() string {
	return "DefaultUTCTimeZone ensures that time-based operations use the UTC timezone rather than the\ninput time's local timezone."
}

// SetEnabled sets the enabled parameter
func (b *DefaultUTCTimeZoneBuilder) SetEnabled(enabled bool) *DefaultUTCTimeZoneBuilder {
	b.Enabled = enabled
	return b
}

// Build creates the CEL environment option
func (b *DefaultUTCTimeZoneBuilder) Build() (cel.EnvOption, error) {
	return cel.DefaultUTCTimeZone(b.Enabled), nil
}
func init() {
	DefaultRegistry.Register("DefaultUTCTimeZone", func() OptionBuilder {
		return &DefaultUTCTimeZoneBuilder{}
	})
}

// EagerlyValidateDeclarations ensures that any collisions between configured declarations are caught
// at the time of the `NewEnv` call.
// Eagerly validating declarations is also useful for bootstrapping a base `cel.Env` value.
// Calls to base `Env.Extend()` will be significantly faster when declarations are eagerly validated
// as declarations will be collision-checked at most once and only incrementally by way of `Extend`
// Disabled by default as not all environments are used for type-checking.
type EagerlyValidateDeclarationsBuilder struct {
	Enabled bool
}

// Name returns the name of this option
func (b *EagerlyValidateDeclarationsBuilder) Name() string {
	return "EagerlyValidateDeclarations"
}

// Description returns the description of this option
func (b *EagerlyValidateDeclarationsBuilder) Description() string {
	return "EagerlyValidateDeclarations ensures that any collisions between configured declarations are caught\nat the time of the `NewEnv` call.\n\nEagerly validating declarations is also useful for bootstrapping a base `cel.Env` value.\nCalls to base `Env.Extend()` will be significantly faster when declarations are eagerly validated\nas declarations will be collision-checked at most once and only incrementally by way of `Extend`\n\nDisabled by default as not all environments are used for type-checking."
}

// SetEnabled sets the enabled parameter
func (b *EagerlyValidateDeclarationsBuilder) SetEnabled(enabled bool) *EagerlyValidateDeclarationsBuilder {
	b.Enabled = enabled
	return b
}

// Build creates the CEL environment option
func (b *EagerlyValidateDeclarationsBuilder) Build() (cel.EnvOption, error) {
	return cel.EagerlyValidateDeclarations(b.Enabled), nil
}
func init() {
	DefaultRegistry.Register("EagerlyValidateDeclarations", func() OptionBuilder {
		return &EagerlyValidateDeclarationsBuilder{}
	})
}

// EnableErrorOnBadPresenceTest enables error generation when a presence test or optional field
// selection is performed on a primitive type.
type EnableErrorOnBadPresenceTestBuilder struct {
	Value bool
}

// Name returns the name of this option
func (b *EnableErrorOnBadPresenceTestBuilder) Name() string {
	return "EnableErrorOnBadPresenceTest"
}

// Description returns the description of this option
func (b *EnableErrorOnBadPresenceTestBuilder) Description() string {
	return "EnableErrorOnBadPresenceTest enables error generation when a presence test or optional field\nselection is performed on a primitive type."
}

// SetValue sets the value parameter
func (b *EnableErrorOnBadPresenceTestBuilder) SetValue(value bool) *EnableErrorOnBadPresenceTestBuilder {
	b.Value = value
	return b
}

// Build creates the CEL environment option
func (b *EnableErrorOnBadPresenceTestBuilder) Build() (cel.EnvOption, error) {
	return cel.EnableErrorOnBadPresenceTest(b.Value), nil
}
func init() {
	DefaultRegistry.Register("EnableErrorOnBadPresenceTest", func() OptionBuilder {
		return &EnableErrorOnBadPresenceTestBuilder{}
	})
}

// EnableHiddenAccumulatorName sets the parser to use the identifier '@result' for accumulators
// which is not normally accessible from CEL source.
type EnableHiddenAccumulatorNameBuilder struct {
	Enabled bool
}

// Name returns the name of this option
func (b *EnableHiddenAccumulatorNameBuilder) Name() string {
	return "EnableHiddenAccumulatorName"
}

// Description returns the description of this option
func (b *EnableHiddenAccumulatorNameBuilder) Description() string {
	return "EnableHiddenAccumulatorName sets the parser to use the identifier '@result' for accumulators\nwhich is not normally accessible from CEL source."
}

// SetEnabled sets the enabled parameter
func (b *EnableHiddenAccumulatorNameBuilder) SetEnabled(enabled bool) *EnableHiddenAccumulatorNameBuilder {
	b.Enabled = enabled
	return b
}

// Build creates the CEL environment option
func (b *EnableHiddenAccumulatorNameBuilder) Build() (cel.EnvOption, error) {
	return cel.EnableHiddenAccumulatorName(b.Enabled), nil
}
func init() {
	DefaultRegistry.Register("EnableHiddenAccumulatorName", func() OptionBuilder {
		return &EnableHiddenAccumulatorNameBuilder{}
	})
}

// EnableIdentifierEscapeSyntax enables identifier escaping (`) syntax for
// fields.
type EnableIdentifierEscapeSyntaxBuilder struct{}

// Name returns the name of this option
func (b *EnableIdentifierEscapeSyntaxBuilder) Name() string {
	return "EnableIdentifierEscapeSyntax"
}

// Description returns the description of this option
func (b *EnableIdentifierEscapeSyntaxBuilder) Description() string {
	return "EnableIdentifierEscapeSyntax enables identifier escaping (`) syntax for\nfields."
}

// Build creates the CEL environment option
func (b *EnableIdentifierEscapeSyntaxBuilder) Build() (cel.EnvOption, error) {
	return cel.EnableIdentifierEscapeSyntax(), nil
}
func init() {
	DefaultRegistry.Register("EnableIdentifierEscapeSyntax", func() OptionBuilder {
		return &EnableIdentifierEscapeSyntaxBuilder{}
	})
}

// EnableMacroCallTracking ensures that call expressions which are replaced by macros
// are tracked in the `SourceInfo` of parsed and checked expressions.
type EnableMacroCallTrackingBuilder struct{}

// Name returns the name of this option
func (b *EnableMacroCallTrackingBuilder) Name() string {
	return "EnableMacroCallTracking"
}

// Description returns the description of this option
func (b *EnableMacroCallTrackingBuilder) Description() string {
	return "EnableMacroCallTracking ensures that call expressions which are replaced by macros\nare tracked in the `SourceInfo` of parsed and checked expressions."
}

// Build creates the CEL environment option
func (b *EnableMacroCallTrackingBuilder) Build() (cel.EnvOption, error) {
	return cel.EnableMacroCallTracking(), nil
}
func init() {
	DefaultRegistry.Register("EnableMacroCallTracking", func() OptionBuilder {
		return &EnableMacroCallTrackingBuilder{}
	})
}

// ExtendedValidations collects a set of common AST validations which reduce the likelihood of runtime errors.
// - Validate duration and timestamp literals
// - Ensure regex strings are valid
// - Disable mixed type list and map literals
type ExtendedValidationsBuilder struct{}

// Name returns the name of this option
func (b *ExtendedValidationsBuilder) Name() string {
	return "ExtendedValidations"
}

// Description returns the description of this option
func (b *ExtendedValidationsBuilder) Description() string {
	return "ExtendedValidations collects a set of common AST validations which reduce the likelihood of runtime errors.\n\n- Validate duration and timestamp literals\n- Ensure regex strings are valid\n- Disable mixed type list and map literals"
}

// Build creates the CEL environment option
func (b *ExtendedValidationsBuilder) Build() (cel.EnvOption, error) {
	return cel.ExtendedValidations(), nil
}
func init() {
	DefaultRegistry.Register("ExtendedValidations", func() OptionBuilder {
		return &ExtendedValidationsBuilder{}
	})
}

// Function defines a function and overloads with optional singleton or per-overload bindings.
// Using Function is roughly equivalent to calling Declarations() to declare the function signatures
// and Functions() to define the function bindings, if they have been defined. Specifying the
// same function name more than once will result in the aggregation of the function overloads. If any
// signatures conflict between the existing and new function definition an error will be raised.
// However, if the signatures are identical and the overload ids are the same, the redefinition will
// be considered a no-op.
// One key difference with using Function() is that each FunctionDecl provided will handle dynamic
// dispatch based on the type-signatures of the overloads provided which means overload resolution at
// runtime is handled out of the box rather than via a custom binding for overload resolution via
// Functions():
// - Overloads are searched in the order they are declared
// - Dynamic dispatch for lists and maps is limited by inspection of the list and map contents
// at runtime. Empty lists and maps will result in a 'default dispatch'
// - In the event that a default dispatch occurs, the first overload provided is the one invoked
// If you intend to use overloads which differentiate based on the key or element type of a list or
// map, consider using a generic function instead: e.g. func(list(T)) or func(map(K, V)) as this
// will allow your implementation to determine how best to handle dispatch and the default behavior
// for empty lists and maps whose contents cannot be inspected.
// For functions which use parameterized opaque types (abstract types), consider using a singleton
// function which is capable of inspecting the contents of the type and resolving the appropriate
// overload as CEL can only make inferences by type-name regarding such types.
type FunctionBuilder struct {
	NameValue string
	Opts      []cel.FunctionOpt
}

// Name returns the name of this option
func (b *FunctionBuilder) Name() string {
	return "Function"
}

// Description returns the description of this option
func (b *FunctionBuilder) Description() string {
	return "Function defines a function and overloads with optional singleton or per-overload bindings.\n\nUsing Function is roughly equivalent to calling Declarations() to declare the function signatures\nand Functions() to define the function bindings, if they have been defined. Specifying the\nsame function name more than once will result in the aggregation of the function overloads. If any\nsignatures conflict between the existing and new function definition an error will be raised.\nHowever, if the signatures are identical and the overload ids are the same, the redefinition will\nbe considered a no-op.\n\nOne key difference with using Function() is that each FunctionDecl provided will handle dynamic\ndispatch based on the type-signatures of the overloads provided which means overload resolution at\nruntime is handled out of the box rather than via a custom binding for overload resolution via\nFunctions():\n\n- Overloads are searched in the order they are declared\n- Dynamic dispatch for lists and maps is limited by inspection of the list and map contents\n\n\tat runtime. Empty lists and maps will result in a 'default dispatch'\n\n- In the event that a default dispatch occurs, the first overload provided is the one invoked\n\nIf you intend to use overloads which differentiate based on the key or element type of a list or\nmap, consider using a generic function instead: e.g. func(list(T)) or func(map(K, V)) as this\nwill allow your implementation to determine how best to handle dispatch and the default behavior\nfor empty lists and maps whose contents cannot be inspected.\n\nFor functions which use parameterized opaque types (abstract types), consider using a singleton\nfunction which is capable of inspecting the contents of the type and resolving the appropriate\noverload as CEL can only make inferences by type-name regarding such types."
}

// SetName sets the name parameter
func (b *FunctionBuilder) SetName(name string) *FunctionBuilder {
	b.NameValue = name
	return b
}

// SetOpts sets the opts parameter
func (b *FunctionBuilder) SetOpts(opts []cel.FunctionOpt) *FunctionBuilder {
	b.Opts = opts
	return b
}

// Build creates the CEL environment option
func (b *FunctionBuilder) Build() (cel.EnvOption, error) {
	return cel.Function(b.NameValue, b.Opts...), nil
}
func init() {
	DefaultRegistry.Register("Function", func() OptionBuilder {
		return &FunctionBuilder{}
	})
}

// FunctionDecls provides one or more fully formed function declarations to be added to the environment.
type FunctionDeclsBuilder struct {
	Funcs []*decls.FunctionDecl
}

// Name returns the name of this option
func (b *FunctionDeclsBuilder) Name() string {
	return "FunctionDecls"
}

// Description returns the description of this option
func (b *FunctionDeclsBuilder) Description() string {
	return "FunctionDecls provides one or more fully formed function declarations to be added to the environment."
}

// SetFuncs sets the funcs parameter
func (b *FunctionDeclsBuilder) SetFuncs(funcs []*decls.FunctionDecl) *FunctionDeclsBuilder {
	b.Funcs = funcs
	return b
}

// Build creates the CEL environment option
func (b *FunctionDeclsBuilder) Build() (cel.EnvOption, error) {
	return cel.FunctionDecls(b.Funcs...), nil
}
func init() {
	DefaultRegistry.Register("FunctionDecls", func() OptionBuilder {
		return &FunctionDeclsBuilder{}
	})
}

// HomogeneousAggregateLiterals disables mixed type list and map literal values.
// Note, it is still possible to have heterogeneous aggregates when provided as variables to the
// expression, as well as via conversion of well-known dynamic types, or with unchecked
// expressions.
type HomogeneousAggregateLiteralsBuilder struct{}

// Name returns the name of this option
func (b *HomogeneousAggregateLiteralsBuilder) Name() string {
	return "HomogeneousAggregateLiterals"
}

// Description returns the description of this option
func (b *HomogeneousAggregateLiteralsBuilder) Description() string {
	return "HomogeneousAggregateLiterals disables mixed type list and map literal values.\n\nNote, it is still possible to have heterogeneous aggregates when provided as variables to the\nexpression, as well as via conversion of well-known dynamic types, or with unchecked\nexpressions."
}

// Build creates the CEL environment option
func (b *HomogeneousAggregateLiteralsBuilder) Build() (cel.EnvOption, error) {
	return cel.HomogeneousAggregateLiterals(), nil
}
func init() {
	DefaultRegistry.Register("HomogeneousAggregateLiterals", func() OptionBuilder {
		return &HomogeneousAggregateLiteralsBuilder{}
	})
}

// Lib creates an EnvOption out of a Library, allowing libraries to be provided as functional args,
// and to be linked to each other.
type LibBuilder struct {
	L cel.Library
}

// Name returns the name of this option
func (b *LibBuilder) Name() string {
	return "Lib"
}

// Description returns the description of this option
func (b *LibBuilder) Description() string {
	return "Lib creates an EnvOption out of a Library, allowing libraries to be provided as functional args,\nand to be linked to each other."
}

// SetL sets the l parameter
func (b *LibBuilder) SetL(l cel.Library) *LibBuilder {
	b.L = l
	return b
}

// Build creates the CEL environment option
func (b *LibBuilder) Build() (cel.EnvOption, error) {
	return cel.Lib(b.L), nil
}
func init() {
	DefaultRegistry.Register("Lib", func() OptionBuilder {
		return &LibBuilder{}
	})
}

// Macros returns a shallow copy of macros associated with the environment.
type MacrosBuilder struct {
	Macros []cel.Macro
}

// Name returns the name of this option
func (b *MacrosBuilder) Name() string {
	return "Macros"
}

// Description returns the description of this option
func (b *MacrosBuilder) Description() string {
	return "Macros returns a shallow copy of macros associated with the environment."
}

// SetMacros sets the macros parameter
func (b *MacrosBuilder) SetMacros(macros []cel.Macro) *MacrosBuilder {
	b.Macros = macros
	return b
}

// Build creates the CEL environment option
func (b *MacrosBuilder) Build() (cel.EnvOption, error) {
	return cel.Macros(b.Macros...), nil
}
func init() {
	DefaultRegistry.Register("Macros", func() OptionBuilder {
		return &MacrosBuilder{}
	})
}

// OptionalTypes enable support for optional syntax and types in CEL.
// The optional value type makes it possible to express whether variables have
// been provided, whether a result has been computed, and in the future whether
// an object field path, map key value, or list index has a value.
// # Syntax Changes
// OptionalTypes are unlike other CEL extensions because they modify the CEL
// syntax itself, notably through the use of a `?` preceding a field name or
// index value.
// ## Field Selection
// The optional syntax in field selection is denoted as `obj.?field`. In other
// words, if a field is set, return `optional.of(obj.field)“, else
// `optional.none()`. The optional field selection is viral in the sense that
// after the first optional selection all subsequent selections or indices
// are treated as optional, i.e. the following expressions are equivalent:
// obj.?field.subfield
// obj.?field.?subfield
// ## Indexing
// Similar to field selection, the optional syntax can be used in index
// expressions on maps and lists:
// list[?0]
// map[?key]
// ## Optional Field Setting
// When creating map or message literals, if a field may be optionally set
// based on its presence, then placing a `?` before the field name or key
// will ensure the type on the right-hand side must be optional(T) where T
// is the type of the field or key-value.
// The following returns a map with the key expression set only if the
// subfield is present, otherwise an empty map is created:
// {?key: obj.?field.subfield}
// ## Optional Element Setting
// When creating list literals, an element in the list may be optionally added
// when the element expression is preceded by a `?`:
// [a, ?b, ?c] // return a list with either [a], [a, b], [a, b, c], or [a, c]
// # Optional.Of
// Create an optional(T) value of a given value with type T.
// optional.of(10)
// # Optional.OfNonZeroValue
// Create an optional(T) value of a given value with type T if it is not a
// zero-value. A zero-value the default empty value for any given CEL type,
// including empty protobuf message types. If the value is empty, the result
// of this call will be optional.none().
// optional.ofNonZeroValue([1, 2, 3]) // optional(list(int))
// optional.ofNonZeroValue([]) // optional.none()
// optional.ofNonZeroValue(0)  // optional.none()
// optional.ofNonZeroValue("") // optional.none()
// # Optional.None
// Create an empty optional value.
// # HasValue
// Determine whether the optional contains a value.
// optional.of(b'hello').hasValue() // true
// optional.ofNonZeroValue({}).hasValue() // false
// # Value
// Get the value contained by the optional. If the optional does not have a
// value, the result will be a CEL error.
// optional.of(b'hello').value() // b'hello'
// optional.ofNonZeroValue({}).value() // error
// # Or
// If the value on the left-hand side is optional.none(), the optional value
// on the right hand side is returned. If the value on the left-hand set is
// valued, then it is returned. This operation is short-circuiting and will
// only evaluate as many links in the `or` chain as are needed to return a
// non-empty optional value.
// obj.?field.or(m[?key])
// l[?index].or(obj.?field.subfield).or(obj.?other)
// # OrValue
// Either return the value contained within the optional on the left-hand side
// or return the alternative value on the right hand side.
// m[?key].orValue("none")
// # OptMap
// Apply a transformation to the optional's underlying value if it is not empty
// and return an optional typed result based on the transformation. The
// transformation expression type must return a type T which is wrapped into
// an optional.
// msg.?elements.optMap(e, e.size()).orValue(0)
// # OptFlatMap
// Introduced in version: 1
// Apply a transformation to the optional's underlying value if it is not empty
// and return the result. The transform expression must return an optional(T)
// rather than type T. This can be useful when dealing with zero values and
// conditionally generating an empty or non-empty result in ways which cannot
// be expressed with `optMap`.
// msg.?elements.optFlatMap(e, e[?0]) // return the first element if present.
// # First
// Introduced in version: 2
// Returns an optional with the first value from the right hand list, or
// optional.None.
// [1, 2, 3].first().value() == 1
// # Last
// Introduced in version: 2
// Returns an optional with the last value from the right hand list, or
// optional.None.
// [1, 2, 3].last().value() == 3
// This is syntactic sugar for msg.elements[msg.elements.size()-1].
// # Unwrap / UnwrapOpt
// Introduced in version: 2
// Returns a list of all the values that are not none in the input list of optional values.
// Can be used as optional.unwrap(List[T]) or with postfix notation: List[T].unwrapOpt()
// optional.unwrap([optional.of(42), optional.none()]) == [42]
// [optional.of(42), optional.none()].unwrapOpt() == [42]
type OptionalTypesBuilder struct {
	Opts []cel.OptionalTypesOption
}

// Name returns the name of this option
func (b *OptionalTypesBuilder) Name() string {
	return "OptionalTypes"
}

// Description returns the description of this option
func (b *OptionalTypesBuilder) Description() string {
	return "OptionalTypes enable support for optional syntax and types in CEL.\n\nThe optional value type makes it possible to express whether variables have\nbeen provided, whether a result has been computed, and in the future whether\nan object field path, map key value, or list index has a value.\n\n# Syntax Changes\n\nOptionalTypes are unlike other CEL extensions because they modify the CEL\nsyntax itself, notably through the use of a `?` preceding a field name or\nindex value.\n\n## Field Selection\n\nThe optional syntax in field selection is denoted as `obj.?field`. In other\nwords, if a field is set, return `optional.of(obj.field)“, else\n`optional.none()`. The optional field selection is viral in the sense that\nafter the first optional selection all subsequent selections or indices\nare treated as optional, i.e. the following expressions are equivalent:\n\n\tobj.?field.subfield\n\tobj.?field.?subfield\n\n## Indexing\n\nSimilar to field selection, the optional syntax can be used in index\nexpressions on maps and lists:\n\n\tlist[?0]\n\tmap[?key]\n\n## Optional Field Setting\n\nWhen creating map or message literals, if a field may be optionally set\nbased on its presence, then placing a `?` before the field name or key\nwill ensure the type on the right-hand side must be optional(T) where T\nis the type of the field or key-value.\n\nThe following returns a map with the key expression set only if the\nsubfield is present, otherwise an empty map is created:\n\n\t{?key: obj.?field.subfield}\n\n## Optional Element Setting\n\nWhen creating list literals, an element in the list may be optionally added\nwhen the element expression is preceded by a `?`:\n\n\t[a, ?b, ?c] // return a list with either [a], [a, b], [a, b, c], or [a, c]\n\n# Optional.Of\n\nCreate an optional(T) value of a given value with type T.\n\n\toptional.of(10)\n\n# Optional.OfNonZeroValue\n\nCreate an optional(T) value of a given value with type T if it is not a\nzero-value. A zero-value the default empty value for any given CEL type,\nincluding empty protobuf message types. If the value is empty, the result\nof this call will be optional.none().\n\n\toptional.ofNonZeroValue([1, 2, 3]) // optional(list(int))\n\toptional.ofNonZeroValue([]) // optional.none()\n\toptional.ofNonZeroValue(0)  // optional.none()\n\toptional.ofNonZeroValue(\"\") // optional.none()\n\n# Optional.None\n\nCreate an empty optional value.\n\n# HasValue\n\nDetermine whether the optional contains a value.\n\n\toptional.of(b'hello').hasValue() // true\n\toptional.ofNonZeroValue({}).hasValue() // false\n\n# Value\n\nGet the value contained by the optional. If the optional does not have a\nvalue, the result will be a CEL error.\n\n\toptional.of(b'hello').value() // b'hello'\n\toptional.ofNonZeroValue({}).value() // error\n\n# Or\n\nIf the value on the left-hand side is optional.none(), the optional value\non the right hand side is returned. If the value on the left-hand set is\nvalued, then it is returned. This operation is short-circuiting and will\nonly evaluate as many links in the `or` chain as are needed to return a\nnon-empty optional value.\n\n\tobj.?field.or(m[?key])\n\tl[?index].or(obj.?field.subfield).or(obj.?other)\n\n# OrValue\n\nEither return the value contained within the optional on the left-hand side\nor return the alternative value on the right hand side.\n\n\tm[?key].orValue(\"none\")\n\n# OptMap\n\nApply a transformation to the optional's underlying value if it is not empty\nand return an optional typed result based on the transformation. The\ntransformation expression type must return a type T which is wrapped into\nan optional.\n\n\tmsg.?elements.optMap(e, e.size()).orValue(0)\n\n# OptFlatMap\n\nIntroduced in version: 1\n\nApply a transformation to the optional's underlying value if it is not empty\nand return the result. The transform expression must return an optional(T)\nrather than type T. This can be useful when dealing with zero values and\nconditionally generating an empty or non-empty result in ways which cannot\nbe expressed with `optMap`.\n\n\tmsg.?elements.optFlatMap(e, e[?0]) // return the first element if present.\n\n# First\n\nIntroduced in version: 2\n\nReturns an optional with the first value from the right hand list, or\noptional.None.\n\n[1, 2, 3].first().value() == 1\n\n# Last\n\nIntroduced in version: 2\n\nReturns an optional with the last value from the right hand list, or\noptional.None.\n\n[1, 2, 3].last().value() == 3\n\nThis is syntactic sugar for msg.elements[msg.elements.size()-1].\n\n# Unwrap / UnwrapOpt\n\nIntroduced in version: 2\n\nReturns a list of all the values that are not none in the input list of optional values.\nCan be used as optional.unwrap(List[T]) or with postfix notation: List[T].unwrapOpt()\n\noptional.unwrap([optional.of(42), optional.none()]) == [42]\n[optional.of(42), optional.none()].unwrapOpt() == [42]"
}

// SetOpts sets the opts parameter
func (b *OptionalTypesBuilder) SetOpts(opts []cel.OptionalTypesOption) *OptionalTypesBuilder {
	b.Opts = opts
	return b
}

// Build creates the CEL environment option
func (b *OptionalTypesBuilder) Build() (cel.EnvOption, error) {
	return cel.OptionalTypes(b.Opts...), nil
}
func init() {
	DefaultRegistry.Register("OptionalTypes", func() OptionBuilder {
		return &OptionalTypesBuilder{}
	})
}

// ParserExpressionSizeLimit adjusts the number of code points the expression parser is allowed to parse.
// Defaults defined in the parser package.
type ParserExpressionSizeLimitBuilder struct {
	Limit int
}

// Name returns the name of this option
func (b *ParserExpressionSizeLimitBuilder) Name() string {
	return "ParserExpressionSizeLimit"
}

// Description returns the description of this option
func (b *ParserExpressionSizeLimitBuilder) Description() string {
	return "ParserExpressionSizeLimit adjusts the number of code points the expression parser is allowed to parse.\nDefaults defined in the parser package."
}

// SetLimit sets the limit parameter
func (b *ParserExpressionSizeLimitBuilder) SetLimit(limit int) *ParserExpressionSizeLimitBuilder {
	b.Limit = limit
	return b
}

// Build creates the CEL environment option
func (b *ParserExpressionSizeLimitBuilder) Build() (cel.EnvOption, error) {
	return cel.ParserExpressionSizeLimit(b.Limit), nil
}
func init() {
	DefaultRegistry.Register("ParserExpressionSizeLimit", func() OptionBuilder {
		return &ParserExpressionSizeLimitBuilder{}
	})
}

// ParserRecursionLimit adjusts the AST depth the parser will tolerate.
// Defaults defined in the parser package.
type ParserRecursionLimitBuilder struct {
	Limit int
}

// Name returns the name of this option
func (b *ParserRecursionLimitBuilder) Name() string {
	return "ParserRecursionLimit"
}

// Description returns the description of this option
func (b *ParserRecursionLimitBuilder) Description() string {
	return "ParserRecursionLimit adjusts the AST depth the parser will tolerate.\nDefaults defined in the parser package."
}

// SetLimit sets the limit parameter
func (b *ParserRecursionLimitBuilder) SetLimit(limit int) *ParserRecursionLimitBuilder {
	b.Limit = limit
	return b
}

// Build creates the CEL environment option
func (b *ParserRecursionLimitBuilder) Build() (cel.EnvOption, error) {
	return cel.ParserRecursionLimit(b.Limit), nil
}
func init() {
	DefaultRegistry.Register("ParserRecursionLimit", func() OptionBuilder {
		return &ParserRecursionLimitBuilder{}
	})
}

// StdLib returns an EnvOption for the standard library of CEL functions and macros.
type StdLibBuilder struct {
	Opts []cel.StdLibOption
}

// Name returns the name of this option
func (b *StdLibBuilder) Name() string {
	return "StdLib"
}

// Description returns the description of this option
func (b *StdLibBuilder) Description() string {
	return "StdLib returns an EnvOption for the standard library of CEL functions and macros."
}

// SetOpts sets the opts parameter
func (b *StdLibBuilder) SetOpts(opts []cel.StdLibOption) *StdLibBuilder {
	b.Opts = opts
	return b
}

// Build creates the CEL environment option
func (b *StdLibBuilder) Build() (cel.EnvOption, error) {
	return cel.StdLib(b.Opts...), nil
}
func init() {
	DefaultRegistry.Register("StdLib", func() OptionBuilder {
		return &StdLibBuilder{}
	})
}

// Variable creates an instance of a variable declaration with a variable name and type.
type VariableBuilder struct {
	NameValue string
	T         *cel.Type
}

// Name returns the name of this option
func (b *VariableBuilder) Name() string {
	return "Variable"
}

// Description returns the description of this option
func (b *VariableBuilder) Description() string {
	return "Variable creates an instance of a variable declaration with a variable name and type."
}

// SetName sets the name parameter
func (b *VariableBuilder) SetName(name string) *VariableBuilder {
	b.NameValue = name
	return b
}

// SetT sets the t parameter
func (b *VariableBuilder) SetT(t *cel.Type) *VariableBuilder {
	b.T = t
	return b
}

// Build creates the CEL environment option
func (b *VariableBuilder) Build() (cel.EnvOption, error) {
	return cel.Variable(b.NameValue, b.T), nil
}
func init() {
	DefaultRegistry.Register("Variable", func() OptionBuilder {
		return &VariableBuilder{}
	})
}

// VariableDecls configures a set of fully defined cel.VariableDecl instances in the environment.
type VariableDeclsBuilder struct {
	Vars []*decls.VariableDecl
}

// Name returns the name of this option
func (b *VariableDeclsBuilder) Name() string {
	return "VariableDecls"
}

// Description returns the description of this option
func (b *VariableDeclsBuilder) Description() string {
	return "VariableDecls configures a set of fully defined cel.VariableDecl instances in the environment."
}

// SetVars sets the vars parameter
func (b *VariableDeclsBuilder) SetVars(vars []*decls.VariableDecl) *VariableDeclsBuilder {
	b.Vars = vars
	return b
}

// Build creates the CEL environment option
func (b *VariableDeclsBuilder) Build() (cel.EnvOption, error) {
	return cel.VariableDecls(b.Vars...), nil
}
func init() {
	DefaultRegistry.Register("VariableDecls", func() OptionBuilder {
		return &VariableDeclsBuilder{}
	})
}

// VariableWithDoc creates an instance of a variable declaration with a variable name, type, and doc string.
type VariableWithDocBuilder struct {
	NameValue string
	T         *cel.Type
	Doc       string
}

// Name returns the name of this option
func (b *VariableWithDocBuilder) Name() string {
	return "VariableWithDoc"
}

// Description returns the description of this option
func (b *VariableWithDocBuilder) Description() string {
	return "VariableWithDoc creates an instance of a variable declaration with a variable name, type, and doc string."
}

// SetName sets the name parameter
func (b *VariableWithDocBuilder) SetName(name string) *VariableWithDocBuilder {
	b.NameValue = name
	return b
}

// SetT sets the t parameter
func (b *VariableWithDocBuilder) SetT(t *cel.Type) *VariableWithDocBuilder {
	b.T = t
	return b
}

// SetDoc sets the doc parameter
func (b *VariableWithDocBuilder) SetDoc(doc string) *VariableWithDocBuilder {
	b.Doc = doc
	return b
}

// Build creates the CEL environment option
func (b *VariableWithDocBuilder) Build() (cel.EnvOption, error) {
	return cel.VariableWithDoc(b.NameValue, b.T, b.Doc), nil
}
func init() {
	DefaultRegistry.Register("VariableWithDoc", func() OptionBuilder {
		return &VariableWithDocBuilder{}
	})
}
